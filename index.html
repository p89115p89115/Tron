<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, height=device-height, interactive-widget=resizes-content, shrink-to-fit=0,user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
  <meta property="og:title" content="Aurelia - ThreeJS WebGPU Experiment - holtsetio.com" />
  <meta property="og:image" content="https://holtsetio.com/img/lab/aurelia.jpg" />
  <title>3D Sketcher — FlyCam + Deep Sea Background</title>
  <style>
    html, body { height: 100%; }
    body { overflow: hidden; margin: 0; padding: 0; background: #000; color: #e6f7ff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans"; }

    /* 深海背景容器（由 index.js 產生） */
    #container { position: absolute; inset: 0; display: block; z-index: 0; }
    #veil { position: absolute; inset: 0; background-color: black; opacity: 1; pointer-events: none; transition: opacity 1s ease-in-out; z-index: 5; }
    #progress-bar { position: absolute; width: 200px; height: 5px; left: 50vw; top: 50vh; transition: opacity 0.2s ease; transform: translateX(-50%) translateY(-50%); background-color: #333; }
    #progress { position: absolute; width: 0px; height: 5px; left: 0; top: 0; transition: width 0.2s ease; background-color: #848484; }
    #error { position: absolute; left: 50vw; top: 50vh; transform: translateX(-50%) translateY(-50%); color: #FFFFFF; visibility: hidden; }

    /* 主畫布（Sketcher） */
    #canvas {
      position: absolute;
      inset: 0;
      display: block;
      z-index: 2;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
      pointer-events: none;
      background-color: transparent;
    }
    .dg.ac { z-index: 10; }
    #hint { position: fixed; left: 12px; bottom: 12px; font-size: 12px; opacity: .95; pointer-events: none;
      text-shadow: 0 0 10px rgba(0,255,255,.35); line-height: 1.4; z-index: 3; }
    kbd{background:#0f1a2e; border:1px solid #1e2b47; border-bottom-color:#0d1324; padding:2px 6px; border-radius:4px;}
    .topbar{position:fixed;left:12px;top:12px;z-index:99999;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .btn{padding:6px 12px;border:1px solid #888;background:#111;color:#fff;border-radius:6px;cursor:pointer}
    .lbl{display:flex;align-items:center;gap:6px;color:#eee;font:12px sans-serif}
    .num{width:110px;padding:4px 6px;background:#0b1220;border:1px solid #334;color:#dfe}
  
    /* ==== UI FIXES: make sure right-side dat.GUI is always clickable ==== */
    .dg.ac { position: fixed !important; top: 0; right: 0 !important; z-index: 2147483647 !important; pointer-events: auto !important; }
    .dg .close-button { pointer-events: auto !important; }
    .topbar { pointer-events: auto !important; }
    #canvas { pointer-events: none; }
    #veil, #progress-bar, #progress { pointer-events: none; }

  </style>
</head>
<body>
  <!-- 深海背景場景（WebGPU/WebGL） -->
  <div id="container">
    <div id="veil">
      <div id="progress-bar"><div id="progress"></div></div>
      <div id="error"></div>
    </div>
  </div>

  <!-- 主互動畫布 -->
  <canvas id="canvas"></canvas>
  <div id="hint">
    <div id="hint-orbit">相機（軌道）：<kbd>W/S</kbd> 縮放； <kbd>A/D</kbd> 左右環繞； <kbd>Q/E</kbd> 垂直移動 ｜ 左鍵：畫線。<kbd>T</kbd>：切換 Demo。</div>
    <div id="hint-fly" style="display:none;">相機（自由飛行）：<kbd>W</kbd>推進（沿鏡頭方向加速） <kbd>S</kbd>減速（不倒退） <kbd>A/D</kbd>左右平移 <kbd>Q/E</kbd>上/下；右鍵拖曳視角（飛行模式下禁止畫線）。</div>
  </div>
  <script type="module" src="./index.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>

  <!-- ====== 你的主程式（含 FlyCam thrust：W 推進 / S 減速） ====== -->
  <script>
  (function () {
    const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    // --- Camera State (Orbit + Fly) ---
    const cam = {
      // Orbit
      theta:-1.6, phi:-0.2, radius:9000, velTheta:0, velPhi:0, damping:0.92,
      minPhi:-2, maxPhi:2, y:-4000,
      // Fly
      mode:'orbit', // 'orbit' | 'fly'
      pos:{x:0, y:-4000, z:0}, yaw:-1.6, pitch:-0.2,
    };

    const fly = {
      speed: 30,          // 左右/上下平移基礎速度（A/D/Q/E）
      sprint: 2.0,
      lookSensitivity: 0.0025,
      damping: 0.92,
      // === 推力模型（W=推進 / S=減速） ===
      thrust: 0,            // 當前推力
      thrustMax: 5000,      // 推力上限
      thrustGain: 80,       // 每幀按下W增加的推力量
      thrustBrake: 110,     // 每幀按下S減少的推力量
      thrustDrag: 0.985,    // 未操作時推力自然衰減（空中滑行）
      vel:{x:0,y:0,z:0}
    };

    function hslToRgb(h,s,l){ s/=100;l/=100;const k=n=>(n+h/30)%12;const a=s*Math.min(l,1-l);
      const f=n=>l-a*Math.max(-1,Math.min(k(n)-3,Math.min(9-k(n),1)));
      return {r:Math.round(255*f(0)),g:Math.round(255*f(8)),b:Math.round(255*f(4))}; }
    function randomNeonColor(){ const hues=[190,200,210,220,160,280,300,330,20,45];
      const h=hues[(Math.random()*hues.length)|0]+(Math.random()*10-5);
      return hslToRgb((h+360)%360, 96, 62); }
    function mod(n,m){ return ((n % m) + m) % m; }

    function Line(points, color){ this.points=points||[]; this.dist=0;
      color=color||randomNeonColor(); this.rgb=color;
      this.color='rgb('+~~(color.r)+','+~~(color.g)+','+~~(color.b)+')'; this.anchorRiseY=riseOffsetY; }
    Line.prototype.update=function(){ const p=this.points[this.points.length-1]; this.dist=p?p.z:0; };
    Line.prototype.render=function(ctxCore, _ctxGlow, translateY){
      const lw=settings.lineWidth*DPR; const pts2=scratch2D; pts2.length=0;
      for(let i=0;i<this.points.length;i++){ const p2=projectTo2DWithYOffset(this.points[i], translateY); if(p2) pts2.push(p2); }
      if(pts2.length<2) return;

      // --- Breathing Mode variant (single-line) ---
      if (settings.breathingMode) {
        const t = performance.now() * (settings.breath_timeScale || 0.002);
        const phase = (this._phase ||= Math.random() * Math.PI * 2);
        const axis = (settings.breath_axis === 'y') ? 'y' : 'x';

        for (let i = 0; i < pts2.length; i++) {
          const p = pts2[i];
          const u = (pts2.length > 1) ? (i / (pts2.length - 1)) : 0;
          const envelopeBase = Math.sin(u * Math.PI);
          const envelope = Math.pow(Math.max(0, envelopeBase), Math.max(0.1, settings.breath_envelopePow || 1));
          const wave1 = Math.sin(t + phase) * (settings.breath_wave1Amp || 0);
          const wave2 = Math.sin(u * (settings.breath_wave2UFreq || 8) + t * (settings.breath_wave2TFreq || 2)) * (settings.breath_wave2Amp || 0);
          const wave3 = Math.cos(phase * (settings.breath_wave3PhaseMul || 4) - t)
                        * Math.pow(Math.cos(u * Math.PI - Math.PI / 2), 2)
                        * (settings.breath_wave3Amp || 0);
          const base = (settings.breath_baseline || 0);
          const delta = envelope * (wave1 + wave2 + wave3 + base);
          p[axis] = p[axis] + delta;
        }
      }
    

      if (settings.enableGlow) {
        ctxCore.save();
        ctxCore.setTransform(1,0,0,1,0,0);
        ctxCore.lineCap='round'; ctxCore.lineJoin='round';
        ctxCore.globalCompositeOperation = 'lighter';
        ctxCore.shadowBlur = (settings.glowStrength||8) * DPR;
        ctxCore.shadowColor = this.color;
        ctxCore.lineWidth = lw * 1.8;
        ctxCore.strokeStyle = 'rgba('+(this.rgb.r|0)+','+(this.rgb.g|0)+','+(this.rgb.b|0)+','+(settings.glowAlpha||0.45)+')';
        strokePath2D(ctxCore, pts2); ctxCore.stroke();
        ctxCore.restore();
      }

      ctxCore.save(); ctxCore.setTransform(1,0,0,1,0,0); ctxCore.lineCap='round'; ctxCore.lineJoin='round';
      ctxCore.lineWidth=lw; ctxCore.strokeStyle=this.color; ctxCore.shadowBlur=0; ctxCore.globalAlpha=1;
      strokePath2D(ctxCore, pts2); ctxCore.stroke(); ctxCore.restore();
    };
    function strokePath2D(ctx,pts){ ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y); for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y); }
    function PointWorld(x,y,z){ this.x=x||0; this.y=y||0; this.z=z||0; }
    function rotateY(v,a){ const c=Math.cos(a), s=Math.sin(a); return {x:v.x*c-v.z*s,y:v.y,z:v.z*c+v.x*s}; }
    function rotateX(v,a){ const c=Math.cos(a), s=Math.sin(a); return {x:v.x,y:v.y*c-v.z*s,z:v.z*c+v.y*s}; }

    // --- Projection (supports both orbit & fly) ---
    function projectTo2DWithYOffset(p,yoff){
      let v;
      if (cam.mode === 'fly') {
        v = { x: p.x - cam.pos.x, y: p.y + (yoff||0) - cam.pos.y, z: p.z - cam.pos.z };
        v = rotateY(v, -cam.yaw);
        v = rotateX(v, -cam.pitch);
        v.z += cam.radius; // reuse same near-plane push
      } else {
        v = { x:p.x, y:p.y+(yoff||0)-cam.y, z:p.z };
        v = rotateY(v, -cam.theta);
        v = rotateX(v, -cam.phi);
        v.z += cam.radius;
      }
      const scale=focal/(focal+v.z); if(scale<=0) return null;
      return {x:vpx+v.x*scale, y:vpy+v.y*scale};
    }

    function screenToWorldOnPlane(sx,sy,drawPlaneZ){
      const scaleInv=(focal+drawPlaneZ)/focal;
      const x_cam=(sx-vpx)*scaleInv; const y_cam=(sy-vpy)*scaleInv; const z_cam=drawPlaneZ;
      let v = {x:x_cam, y:y_cam, z:z_cam};
      if (cam.mode === 'fly') {
        v = rotateX(v, +cam.pitch);
        v = rotateY(v, +cam.yaw);
        return new PointWorld(v.x + cam.pos.x, v.y + cam.pos.y, v.z + cam.pos.z);
      } else {
        v = rotateX(v, +cam.phi);
        v = rotateY(v, +cam.theta);
        return new PointWorld(v.x, v.y+cam.y, v.z);
      }
    }

    const canvas=document.getElementById('canvas'); const ctx=canvas.getContext('2d',{alpha:true});
    ctx.imageSmoothingEnabled = true;
    let lines=[], focal=0, vpx=0, vpy=0,
        settings={ strokeColor:randomNeonColor(), lineWidth:0.9, demoMode:false, breathingMode:false, trailAlpha:0.16, orbitStep: 0.002,
                   maxLines:1200, maxPointsPerLine:60000, minSegmentLen:0.2,
                   riseSpeed:2, followRatio:0.35, drawPlaneZ:1200,
                   demoPointsPerFrame: 9, demoStepAmplitude: 900, demoNewLineChance: 0.96, demoPad: 24, demoFullScreen: false,
                   showFloor:true, showRightWall:true, gridStep:240, gridCell:600, gridHalf:10000, gridYRange:90000,
                   gridThin:'rgba(70,160,220,0.20)', gridThick:'rgba(130,210,255,0.45)', gridLabel:'rgba(190,230,255,0.9)', gridFontPx:16,
                   enableGlow:false, glowStrength:9, glowAlpha:0.55,

breath_timeScale: 0.002,   // 時間倍率（整體呼吸速度）
breath_axis: 'x',          // 變形軸向：'x' 或 'y'
breath_wave1Amp: 60,       // 波1 振幅（慢呼吸）
breath_wave2Amp: 40,       // 波2 振幅（細節顫動）
breath_wave2UFreq: 8,      // 波2 沿線 u 的頻率
breath_wave2TFreq: 2,      // 波2 隨時間的頻率
breath_wave3Amp: 100,      // 波3 振幅（中央鼓脹）
breath_wave3PhaseMul: 4,   // 波3 隨 phase 的倍數
breath_baseline: 60,       // 基礎外擴偏移（讓線條不會只左右擺而已）
breath_envelopePow: 1,     // 包絡線強度（>1 更集中於中段）
                   clearScreen(){ lines.length = 0; ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width,canvas.height); } },
        painting=false, points=[], line=null;
    const scratch2D=[]; let riseOffsetY=0;

    function resize(){ const w=Math.floor(window.innerWidth), h=Math.floor(window.innerHeight);
      canvas.style.width=w+'px'; canvas.style.height=h+'px'; canvas.width=w*DPR; canvas.height=h*DPR;
      focal=Math.max(canvas.width, canvas.height)/2; vpx=canvas.width/2; vpy=canvas.height/2;
      ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width,canvas.height);
    }
    window.addEventListener('resize', resize); resize();

    // --- Input ---
    const keys={w:false,s:false,a:false,d:false,q:false,e:false,shift:false,t:false};
    const KEYMAP={87:'w',83:'s',65:'a',68:'d',81:'q',69:'e',84:'t',16:'shift'};
    window.addEventListener('keydown', e=>{ const k=KEYMAP[e.keyCode]; if(k&&keys[k]!==undefined){ keys[k]=true; e.preventDefault(); }
      if(e.keyCode===84){ settings.demoMode = !settings.demoMode; if(settings.demoMode) line=null; }
    });
    window.addEventListener('keyup', e=>{ const k=KEYMAP[e.keyCode]; if(k&&keys[k]!==undefined){ keys[k]=false; e.preventDefault(); }});

    const pointer={ activeId:null, down:false, look:false, lastX:0, lastY:0 };

    function isEventOnUI(target){
      if(!target) return false;
      return Boolean(
        target.closest('.topbar') ||
        target.closest('.dg') ||
        target.closest('.tp-dfwv') ||
        target.closest('.tp-rotv') ||
        target.closest('#hint') ||
        target.closest('#stats') ||
        target.closest('input') ||
        target.closest('select') ||
        target.closest('textarea') ||
        target.closest('button') ||
        target.closest('label')
      );
    }

    function canvasCoordsFromEvent(e){
      const rect = canvas.getBoundingClientRect();
      return {
        x: (e.clientX - rect.left) * DPR,
        y: (e.clientY - rect.top) * DPR,
      };
    }

    function beginLineAtPointer(e){
      const {x, y} = canvasCoordsFromEvent(e);
      points=[];
      line=new Line(points, randomNeonColor());
      lines.push(line);
      if(lines.length>settings.maxLines) lines.splice(0, lines.length-settings.maxLines);
      addPointWorldFromScreen(x,y);
    }

    window.addEventListener('pointerdown', e=>{
      if (isEventOnUI(e.target)) return;
      if (e.button===2 && cam.mode==='fly') {
        pointer.look = true;
        pointer.activeId = e.pointerId;
        pointer.lastX = e.clientX;
        pointer.lastY = e.clientY;
        e.preventDefault();
        return;
      }
      if(e.button!==0) return;
      if(cam.mode==='fly'){ endActivePointer(); return; }
      settings.demoMode=false;
      pointer.down=true;
      pointer.activeId=e.pointerId;
      beginLineAtPointer(e);
      painting=true;
      e.preventDefault();
    }, { passive:false });

    function endActivePointer(){
      pointer.down=false;
      pointer.look=false;
      pointer.activeId=null;
      painting=false;
      line=null;
    }

    window.addEventListener('pointerup', e=>{
      if(pointer.activeId!==null && pointer.activeId!==e.pointerId) return;
      if(pointer.look && e.button===2){ pointer.look=false; pointer.activeId=null; return; }
      if(e.button===0){ endActivePointer(); }
    });
    window.addEventListener('pointercancel', e=>{
      if(pointer.activeId!==null && pointer.activeId!==e.pointerId) return;
      endActivePointer();
    });
    window.addEventListener('blur', endActivePointer);

    window.addEventListener('pointermove', e=>{
      if(pointer.look && cam.mode==='fly' && pointer.activeId===e.pointerId){
        const dx = e.clientX - pointer.lastX; const dy = e.clientY - pointer.lastY;
        pointer.lastX = e.clientX; pointer.lastY = e.clientY;
        // 右鍵拖曳視角（FPS/Unreal）
        cam.yaw   += dx * fly.lookSensitivity;
        cam.pitch -= dy * fly.lookSensitivity;
        cam.pitch = Math.max(-2, Math.min(2, cam.pitch));
        e.preventDefault();
        return;
      }
      if(!pointer.down||pointer.activeId!==e.pointerId||!line) return;
      const {x, y} = canvasCoordsFromEvent(e);
      addPointWorldFromScreen(x,y);
    });

    window.addEventListener('contextmenu', e=>{
      if(isEventOnUI(e.target)) return;
      e.preventDefault();
    });

    function addPointWorldFromScreen(sx,sy){
      const L=line.points.length; const world=screenToWorldOnPlane(sx,sy,settings.drawPlaneZ*DPR);
      if(L>0){ const last=line.points[L-1]; const dx=world.x-last.x, dy=world.y-last.y, dz=world.z-last.z;
        if(dx*dx+dy*dy+dz*dz < (settings.minSegmentLen*settings.minSegmentLen)) return; } line.points.push(world); }

    // ---------- Demo helpers ----------
    function startDemoLine() {
      points = [];
      line = new Line(points, randomNeonColor());
      lines.push(line);
      if (lines.length > settings.maxLines) lines.splice(0, lines.length - settings.maxLines);

      if (settings.demoFullScreen) {
        const pad = Math.max(0, (settings.demoPad|0)) * DPR;
        const sx = pad + Math.random() * (canvas.width - pad * 2);
        const sy = pad + Math.random() * (canvas.height - pad * 2);
        const world0 = screenToWorldOnPlane(sx, sy, settings.drawPlaneZ * DPR);
        line.points.push(world0);
      } else {
        line.points.push(new PointWorld(
          (Math.random()-0.5) * settings.demoStepAmplitude * DPR,
          0,
          (Math.random()-0.5) * settings.demoStepAmplitude * DPR
        ));
      }
    }

    // --- Grid ---
    function drawFloorAndRightWall(){ const step=settings.gridStep*DPR, cell=settings.gridCell*DPR, half=settings.gridHalf*DPR, yRange=settings.gridYRange*DPR;
      const baseY=-(riseOffsetY % step);
      if(settings.showFloor){ for(let x=-half;x<=half;x+=cell){ const pA=projectTo2DWithYOffset({x,y:-300,z:-half},0), pB=projectTo2DWithYOffset({x,y:-300,z:half},0); if(pA&&pB) strokeGridLine(pA,pB,false); }
        for(let z=-half;z<=half;z+=cell){ const pA=projectTo2DWithYOffset({x:-half,y:-10,z},0), pB=projectTo2DWithYOffset({x:half,y:-10,z},0); if(pA&&pB) strokeGridLine(pA,pB,false);} }
      if(settings.showRightWall){ const wallX=half; for(let z=-half;z<=half;z+=cell){ const pA=projectTo2DWithYOffset({x:wallX,y:Math.min(-10,baseY-yRange),z},0);
          const pB=projectTo2DWithYOffset({x:wallX,y:Math.min(-10,baseY+yRange),z},0); if(pA&&pB) strokeGridLine(pA,pB,false); }
        const levels=Math.ceil((2*yRange)/step)+2;
        for(let i=-levels;i<=levels;i++){ const y=baseY+i*step; if(y>-10) continue; const idx=Math.round((riseOffsetY+y)/step);
          const labelVal=mod(idx,31); const isMajor=(labelVal%5===0);
          const pA=projectTo2DWithYOffset({x:wallX,y,z:-half},0), pB=projectTo2DWithYOffset({x:wallX,y,z:half},0); if(pA&&pB) strokeGridLine(pA,pB,isMajor);
          const labelPos=projectTo2DWithYOffset({x:wallX+200*DPR,y,z:half*0.6},0); if(labelPos&&y<=-10) drawLabel(labelPos.x,labelPos.y,labelVal); } } }
    function strokeGridLine(p1,p2,major){ ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y);
      ctx.lineWidth=(major?1.6:1.0)*DPR; ctx.strokeStyle=major?settings.gridThick:settings.gridThin; ctx.stroke(); ctx.restore(); }
    function drawLabel(x,y,val){ ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.font=(settings.gridFontPx*DPR)+'px ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial';
      ctx.fillStyle=settings.gridLabel; ctx.textAlign='left'; ctx.textBaseline='middle'; ctx.fillText(String(val),x,y); ctx.restore(); }

    function loop(){
      // Camera update
      if (cam.mode === 'fly') {
        const base = fly.speed * DPR * (keys.shift ? fly.sprint : 1);

        // === Unreal / FPS style forward = 視角方向 ===
        const cy = Math.cos(cam.yaw), sy = Math.sin(cam.yaw);
        const cp = Math.cos(cam.pitch), sp = Math.sin(cam.pitch);
        const fwd   = { x: Math.sin(cam.yaw) * Math.cos(cam.pitch),
                        y: -Math.sin(cam.pitch),
                        z: Math.cos(cam.yaw) * Math.cos(cam.pitch) };
        const right = { x: cy, y: 0, z: -sy };
        const up    = { x: 0,  y: 1, z: 0 };

        // --- 推力邏輯：W=推進 / S=減速（不倒退） ---
        if (keys.w) fly.thrust += fly.thrustGain * DPR;
        if (keys.s) fly.thrust -= fly.thrustBrake * DPR;

        // 未操作時自然衰減（像鬆油門空滑）
        if (!keys.w && !keys.s) {
          fly.thrust *= fly.thrustDrag;
        }

        // 限制推力範圍（不小於0、不超過上限）
        fly.thrust = Math.max(-10000, Math.min(fly.thrust, fly.thrustMax * DPR));

        // 依推力沿鏡頭方向推進（推力→速度輸入）
        let vx = fwd.x * fly.thrust * -0.02;
        let vy = fwd.y * fly.thrust * 0.02;
        let vz = fwd.z * fly.thrust * 0.02;

        // 平移（A/D/Q/E）維持原本感覺
        if (keys.a) { vx -= right.x*base; vy -= right.y*base; vz += right.z*base; }
        if (keys.d) { vx += right.x*base; vy += right.y*base; vz -= right.z*base; }
        if (keys.q) { vx += up.x*base;   vy += up.y*base;   vz += up.z*base; }
        if (keys.e) { vx -= up.x*base;   vy -= up.y*base;   vz -= up.z*base; }

        // 平滑阻尼（慣性）
        fly.vel.x = fly.vel.x*fly.damping + vx*(1-fly.damping);
        fly.vel.y = fly.vel.y*fly.damping + vy*(1-fly.damping);
        fly.vel.z = fly.vel.z*fly.damping + vz*(1-fly.damping);

        cam.pos.x += fly.vel.x;
        cam.pos.y += fly.vel.y;
        cam.pos.z += fly.vel.z;

        if((painting || settings.demoMode) && !window.__IMPORTING){
          riseOffsetY += settings.riseSpeed*DPR;
        }
      } else {
        const zoomStep=40*DPR, yStep=60*DPR, orbit=(settings.orbitStep||0.02);
        if (keys.w) cam.radius -= zoomStep;
        if (keys.s) cam.radius += zoomStep;
        if (keys.a) cam.velTheta += orbit;
        if (keys.d) cam.velTheta -= orbit;
        if (keys.q) cam.y += yStep;
        if (keys.e) cam.y -= yStep;

        cam.theta += cam.velTheta; cam.velTheta*=cam.damping; cam.velPhi*=cam.damping;
        cam.phi = Math.max(cam.minPhi, Math.min(cam.maxPhi, cam.phi));

        if((painting || settings.demoMode) && !window.__IMPORTING){
          riseOffsetY += settings.riseSpeed*DPR; cam.y -= settings.riseSpeed*settings.followRatio*DPR;
        }
      }

      // Render
      ctx.setTransform(1,0,0,1,0,0); if(settings.breathingMode){   ctx.globalCompositeOperation='destination-out';   ctx.globalAlpha=(settings.trailAlpha||0.12);   ctx.fillStyle='#000';   ctx.fillRect(0,0,canvas.width,canvas.height);   ctx.globalCompositeOperation='source-over';   ctx.globalAlpha=1; } else {   ctx.globalCompositeOperation='source-over';   ctx.globalAlpha=1;   ctx.clearRect(0,0,canvas.width,canvas.height); } // 主畫布清畫（背景自己畫在 #bg）
      drawFloorAndRightWall();

      // --- Demo ---
      if (settings.demoMode && !window.__IMPORTING) {
        if (!line) { startDemoLine(); }
        else {
          const last = line.points[line.points.length-1];
          const amp = settings.demoStepAmplitude * DPR;
          for (let k = 0; k < Math.max(1, (settings.demoPointsPerFrame|0)); k++) {
            const nx = last.x + (Math.random() - 0.5) * amp;
            const ny = last.y + (Math.random() - 0.5) * amp * 0.6;
            const nz = last.z + (Math.random() - 0.5) * amp;
            const world = new PointWorld(nx, ny, nz);
            const dx = world.x - last.x, dy = world.y - last.y, dz = world.z - last.z;
            if ((dx*dx + dy*dy + dz*dz) > (settings.minSegmentLen * settings.minSegmentLen)) {
              line.points.push(world);
            }
          }
          if (Math.random() > settings.demoNewLineChance) { line = null; settings.strokeColor = randomNeonColor(); }
        }
      }

      const active=line; lines.sort((a,b)=>b.dist-a.dist); for(let i=0;i<lines.length;i++) lines[i].update();
      for(let i=0;i<lines.length;i++){ const ln=lines[i]; const yoff=(ln===active)?0:(riseOffsetY - ln.anchorRiseY); ln.render(ctx, null, yoff); }
      requestAnimationFrame(loop);
    }

    // GUI (dat.GUI)
    const gui=new dat.GUI();
    const camUI=gui.addFolder('Camera'); camUI.add(settings, 'orbitStep', 0.0001, 0.02, 0.001).name('左右旋轉速度').listen();
    camUI.add(cam,'radius',400,20000,10).name('鏡頭前後').listen();
    camUI.add(cam,'theta',-Math.PI,Math.PI,0.01).name('鏡頭左右').listen(); camUI.add(cam,'phi',-2,2,0.01).name('鏡頭仰角').listen(); camUI.add(cam,'y',-20000,20000,50).listen(); camUI.close();
    const drawUI=gui.addFolder('Draw'); drawUI.add(settings,'drawPlaneZ',200,3000,50).name('前方平面距離').listen(); drawUI.close();
    const look=gui.addFolder('Look');

// === Breathing 調整 ===
try {
  const breathUI = gui.addFolder('Breathing 調整');
  breathUI.add(settings, 'breath_timeScale', 0.0005, 0.01, 0.0001).name('時間倍率').listen();
  breathUI.add(settings, 'breath_axis', ['x','y']).name('變形軸');
  breathUI.add(settings, 'breath_wave1Amp', 0, 200, 1).name('波1 振幅');
  breathUI.add(settings, 'breath_wave2Amp', 0, 200, 1).name('波2 振幅');
  breathUI.add(settings, 'breath_wave2UFreq', 0, 32, 0.5).name('波2 u頻率');
  breathUI.add(settings, 'breath_wave2TFreq', 0, 10, 0.1).name('波2 時間頻率');
  breathUI.add(settings, 'breath_wave3Amp', 0, 300, 1).name('波3 振幅');
  breathUI.add(settings, 'breath_wave3PhaseMul', 0, 10, 0.1).name('波3 相位倍數');
  breathUI.add(settings, 'breath_baseline', -200, 200, 1).name('基礎外擴');
  breathUI.add(settings, 'breath_envelopePow', 0.3, 4, 0.1).name('包絡強度');
  breathUI.close();
} catch (e) { console.warn('Breathing UI attach failed', e); }
 look.add(settings,'breathingMode').name('Breathing 模式').listen(); look.add(settings,'trailAlpha',0.02,0.3,0.01).name('殘影Alpha').listen(); 
    look.add(settings,'lineWidth',0.4,3,0.1).name('線寬(細)').listen();
    look.add(settings,'enableGlow').name('啟用微光').listen();
    look.add(settings,'glowStrength',0,50,1).name('微光強度').listen();
    look.add(settings,'glowAlpha',0.05,1,0.01).name('微光透明度').listen();
    const misc=gui.addFolder('其他'); misc.add({clear:settings.clearScreen},'clear').name('清空'); misc.add(settings,'riseSpeed',0,10,0.1).name('上升速度');
    misc.add(settings,'followRatio',0,1.2,0.05).name('鏡頭跟隨比例'); misc.close();
    const demoUI = gui.addFolder('Demo');
    demoUI.add(settings, 'demoMode').name('Demo 模式');
    demoUI.add(settings, 'demoFullScreen').name('全版起筆');
    demoUI.add(settings, 'demoPointsPerFrame', 1, 40, 1).name('每幀點數').listen();
    demoUI.add(settings, 'demoStepAmplitude', 50, 2000, 10).name('步幅(世界)').listen();
    demoUI.add(settings, 'demoNewLineChance', 0.5, 0.995, 0.005).name('續畫機率').listen();
    demoUI.add(settings, 'demoPad', 0, 200, 1).name('邊界內縮').listen();

    // --- Top UI (Import / Export / FlyCam) ---
    const wrap=document.createElement('div'); wrap.className='topbar'; document.body.appendChild(wrap);
    function mkBtn(text){ const b=document.createElement('button'); b.textContent=text; b.className='btn'; wrap.appendChild(b); return b; }
    function mkChk(text, checked){ const l=document.createElement('label'); l.className='lbl'; l.innerHTML='<input type="checkbox" '+(checked?'checked':'')+'> '+text; wrap.appendChild(l); return l.querySelector('input'); }
    function mkNum(text, val, step){ const l=document.createElement('label'); l.className='lbl'; l.innerHTML=text+' <input class="num" type="number" step="'+(step||1)+'" value="'+val+'">'; wrap.appendChild(l); return l.querySelector('input'); }

    const btnImp = mkBtn('匯入');
    const btnExp = mkBtn('匯出');
    const chkClear = mkChk('匯入前清空', true);
    const chkProgress = mkChk('逐點重繪（注入）', true);
    const liftInput = mkNum('每檔Y位移(世界單位)', -500, 1);

    const sep = document.createElement('span'); sep.style.margin='0 6px'; sep.textContent='|'; wrap.appendChild(sep);

    const chkFly = mkChk('自由飛行 FlyCam（禁畫）', false);
    const speedInput = mkNum('飛行速度', fly.speed, 50);

    /* === 這裡新增兩個獨立開關：顯示 floor / 顯示 rightWall === */
    const sep2 = document.createElement('span'); sep2.style.margin='0 6px'; sep2.textContent='|'; wrap.appendChild(sep2);

    const chkFloor = mkChk('顯示 floor', true);
    chkFloor.checked = !!settings.showFloor;
    chkFloor.addEventListener('change', ()=>{ settings.showFloor = chkFloor.checked; });

    const chkRightWall = mkChk('顯示 rightWall', true);
    chkRightWall.checked = !!settings.showRightWall;
    chkRightWall.addEventListener('change', ()=>{ settings.showRightWall = chkRightWall.checked; });
    /* === 新增開關結束 === */

    const fileInput=document.createElement('input'); fileInput.type='file'; fileInput.accept='.json,application/json'; fileInput.multiple=true; fileInput.style.display='none'; document.body.appendChild(fileInput);
    btnImp.onclick=()=> fileInput.click();

    function updateHints(){
      document.getElementById('hint-orbit').style.display = (cam.mode==='orbit')?'':'none';
      document.getElementById('hint-fly').style.display = (cam.mode==='fly')?'':'none';
    }

    chkFly.addEventListener('change', ()=>{
      endActivePointer();
      if (chkFly.checked){
        cam.mode = 'fly';
        const yaw = cam.theta; const pitch = cam.phi;
        const cy = Math.cos(yaw), sy = Math.sin(yaw), cp=Math.cos(pitch), sp=Math.sin(pitch);
        const eye = { x: -(Math.sin(yaw)*cp)*cam.radius, y: sp*cam.radius + cam.y, z: -(Math.cos(yaw)*cp)*cam.radius };
        cam.pos.x = 0;
                cam.pos.y = 0;
                cam.pos.z = 0;
        cam.yaw = yaw; cam.pitch = pitch; settings.followRatio = 0;
      } else {
        cam.mode = 'orbit';
      }
      updateHints();
    });

    chkProgress.addEventListener('change', ()=>{ perPointDelay = chkProgress.checked ? 12 : 0; });

    speedInput.addEventListener('change', ()=>{ const v = parseFloat(speedInput.value); if (isFinite(v) && v>0) fly.speed = v; });

    // 匯出（世界座標）
    btnExp.onclick = () => {
      try{
        const env = window._sketchEnv || {};
        const linesRef = window.lines || env.lines;
        const payload = { meta:{ type:'strokesWorld', app:'3D_Sketcher_Grid', dpr: window.devicePixelRatio, exportedAt:new Date().toISOString(), version:'demo_glow_fix_fly_thrust_spacebg' }, strokesWorld: [] };
        if (Array.isArray(linesRef)) {
          for (const L of linesRef) {
            const raw = Array.isArray(L?.points) ? L.points
                      : Array.isArray(L?.pts) ? L.pts
                      : Array.isArray(L?.vertices) ? L.vertices
                      : (typeof L?.getPoints === 'function' ? (L.getPoints() || []) : []);
            const pts = Array.isArray(raw) ? raw.map(p =>
              Array.isArray(p) ? {x:+p[0]||0, y:+p[1]||0, z:+p[2]||0}
                               : {x:+p.x||0,  y:+p.y||0,  z:+p.z||0}
            ) : [];
            if (pts.length >= 2) {
              const entry = { points: pts };
              if (typeof L.color === 'string') entry.color = L.color;
              payload.strokesWorld.push(entry);
            }
          }
        }
        if (!payload.strokesWorld.length) { alert('目前沒有線條可匯出'); return; }
        const blob = new Blob([JSON.stringify(payload, null, 2)], {type:'application/json'});
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'lines_export_' + Date.now() + '.json';
        document.body.appendChild(a); a.click(); a.remove(); setTimeout(() => URL.revokeObjectURL(a.href), 1500);
      }catch(err){ console.error('[export]', err); alert('匯出失敗：' + err.message); }
    };

    // 匯入（與先前版本相容的逐點注入）
    let perPointDelay = 12;
    fileInput.onchange = async (e) => {
      const files = Array.from(e.target.files || []);
      if(!files.length) return;
      try{
        const env = window._sketchEnv || {};
        if(chkClear.checked){
          if(env.settings && typeof env.settings.clearScreen==='function') env.settings.clearScreen();
          if(Array.isArray(env.lines)) env.lines.length = 0;
        }

        const prevFollow = env.settings ? env.settings.followRatio : 0;
        if(env.settings) env.settings.followRatio = 0;
        window.__IMPORTING=true;

        const BASE_LIFT = (+liftInput.value || 0) * (env.DPR||1);
        const DRAW_Z = (env.settings?.drawPlaneZ || 1200) * (env.DPR||1);

        function mapStrokePoints(s, scaleDPR, extraY){
          const raw = Array.isArray(s.points)? s.points : [];
          const lift = extraY || 0;
          return raw.map(p => ({ x:(+p.x||0)*scaleDPR, y:(+p.y||0)*scaleDPR + lift, z:(p.z!=null? +p.z*scaleDPR : DRAW_Z) }));
        }

        async function injectProgressively(strokes, scaleDPR, fileLift){
          const progressive = chkProgress.checked;
          async function appendPointsToLine(lineObj, pts){
            if (!progressive) {
              for(let i=1;i<pts.length;i++){ lineObj.points.push(pts[i]); }
              return;
            }
            for(let i=1;i<pts.length;i++){
              lineObj.points.push(pts[i]);
              await new Promise(r=>requestAnimationFrame(r));
              if(perPointDelay>0) await new Promise(r=>setTimeout(r, perPointDelay));
            }
          }
          for(const s of strokes){
            const pts = mapStrokePoints(s, scaleDPR, fileLift);
            if(pts.length>=2){
              const newL = env._appendLine ? env._appendLine([pts[0]]) : window._appendLine([pts[0]]);
              await appendPointsToLine(newL, pts);
            }
          }
        }

        let totalStrokes = 0;
        for(let i=0;i<files.length;i++){
          const f = files[i];
          const fileLift = (BASE_LIFT||0) * i;
          const text = await f.text();
          const data = JSON.parse(text);
          const strokes = Array.isArray(data?.strokesWorld)? data.strokesWorld : [];
          const exportDPR = (data.meta && +data.meta.dpr) || 1;
          const scaleDPR = exportDPR>0 ? (env.DPR / exportDPR) : 1;
          await injectProgressively(strokes, scaleDPR, fileLift);
          totalStrokes += strokes.length;
        }

        if(env.settings) env.settings.followRatio = prevFollow;
        window.__IMPORTING=false;
        for(const fn of ['tick','render','draw','animate','frame']){ if(typeof window[fn]==='function'){ try{ window[fn](); }catch(e){} } }
        alert('匯入完成：'+files.length+' 檔（總筆數約 '+totalStrokes+'）');
      }catch(err){
        console.error('[import]',err);
        alert('匯入失敗：'+err.message);
      } finally {
        e.target.value='';
        window.__IMPORTING=false;
      }
    };

    // Expose
    window._sketchEnv={lines, settings, DPR, screenToWorldOnPlane, Line}; window.__IMPORTING=false;
    window._appendLine = function(points, color){
      const L = new Line(points.slice(), color || randomNeonColor());
      lines.push(L);
      return L;
    };

    requestAnimationFrame(loop);
  })();
  </script>

  <!-- ==== Import rise-per-point patch v4 ==== -->
  <script>
  (function(){
    function getRisePerPoint(){
      const env = window._sketchEnv || {};
      const dpr = env.DPR || window.devicePixelRatio || 1;
      const speed = (env.settings && typeof env.settings.riseSpeed === 'number') ? env.settings.riseSpeed : 0;
      return speed * dpr;
    }
    function ensureImportState(){ if (window.__IMPORT_RISE_LAST_Y === undefined) window.__IMPORT_RISE_LAST_Y = null; if (window.__IMPORT_RISE_ACTIVE === undefined) window.__IMPORT_RISE_ACTIVE = false; }
    function wrapAppendLine(){
      const origAppend = window._appendLine; if (!origAppend || window._appendLine.__wrappedRiseV4) return;
      window._appendLine = function(points, color){
        ensureImportState(); const importing = !!window.__IMPORTING; const rise = getRisePerPoint();
        const pts = Array.isArray(points) ? points.map(p => ({x:p.x, y:p.y, z:p.z})) : [];
        const line = origAppend.call(this, pts, color);
        if (importing && line && Array.isArray(line.points) && !line.points.__pushWrappedRiseV4) {
          window.__IMPORT_RISE_ACTIVE = true;
          if (line.points.length >= 1) {
            const first = line.points[0];
            if (window.__IMPORT_RISE_LAST_Y == null) { window.__IMPORT_RISE_LAST_Y = first.y; }
            else { first.y = window.__IMPORT_RISE_LAST_Y - rise; window.__IMPORT_RISE_LAST_Y = first.y; }
          }
          for (let i = 1; i < line.points.length; i++) { line.points[i].y = line.points[i-1].y - rise; window.__IMPORT_RISE_LAST_Y = line.points[i].y; }
          const origPush = line.points.push.bind(line.points);
          line.points.push = function(p){ const baseY = (window.__IMPORT_RISE_LAST_Y != null) ? window.__IMPORT_RISE_LAST_Y : (line.points.length ? line.points[line.points.length - 1].y : (p && p.y) || 0); const newPt = { x: p.x, y: baseY - rise, z: p.z }; window.__IMPORT_RISE_LAST_Y = newPt.y; return origPush(newPt); };
          line.points.__pushWrappedRiseV4 = true; console.log('[import/rise v4] cumulative across lines enabled.');
        }
        return line;
      };
      window._appendLine.__wrappedRiseV4 = true; console.log('[import/rise v4] _appendLine wrapped (cumulative across lines).');
    }
    function monitorImportFlag(){ ensureImportState(); if (!window.__IMPORT_RISE_ACTIVE) return; if (!window.__IMPORTING) { window.__IMPORT_RISE_LAST_Y = null; window.__IMPORT_RISE_ACTIVE = false; console.log('[import/rise v4] import finished, reset last Y.'); } setTimeout(monitorImportFlag, 300); }
    function init(){ try{ wrapAppendLine(); }catch(e){ console.warn(e); } setTimeout(monitorImportFlag, 300); }
    init(); window.addEventListener('load', init); setTimeout(init, 300); setTimeout(init, 1200); setTimeout(init, 2500);
  })();
  </script>


</body>
</html>

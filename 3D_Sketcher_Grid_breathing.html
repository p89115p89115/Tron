<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>3D Sketcher — FlyCam + Space BG（W=推進 / S=減速）</title>
  <style>
    html, body { height: 100%; }
    body { overflow: hidden; margin: 0; padding: 0; background: #000; color: #e6f7ff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans"; }
    /* 背景層（單純太空感星空） */
    #bg { position: absolute; inset: 0; display: block; z-index: 0; background: radial-gradient(1200px 900px at 50% 60%, #0a0f1c 0%, #04070f 55%, #010309 100%); }
    /* 主畫布（你的 Sketcher） */
    #canvas { position: absolute; inset: 0; display: block; z-index: 2; }
    .dg.ac { z-index: 10; }
    #hint { position: fixed; left: 12px; bottom: 12px; font-size: 12px; opacity: .95; pointer-events: none;
      text-shadow: 0 0 10px rgba(0,255,255,.35); line-height: 1.4; z-index: 3; }
    kbd{background:#0f1a2e; border:1px solid #1e2b47; border-bottom-color:#0d1324; padding:2px 6px; border-radius:4px;}
    .topbar{position:fixed;left:12px;top:12px;z-index:99999;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .btn{padding:6px 12px;border:1px solid #888;background:#111;color:#fff;border-radius:6px;cursor:pointer}
    .lbl{display:flex;align-items:center;gap:6px;color:#eee;font:12px sans-serif}
    .num{width:110px;padding:4px 6px;background:#0b1220;border:1px solid #334;color:#dfe}
  
    /* ==== UI FIXES: make sure right-side dat.GUI is always clickable ==== */
    .dg.ac { position: fixed !important; top: 0; right: 0 !important; z-index: 2147483647 !important; pointer-events: auto !important; }
    .dg .close-button { pointer-events: auto !important; }
    .topbar { pointer-events: auto !important; }
    #canvas { pointer-events: auto; }
    #bg { pointer-events: none; } /* background never captures clicks */

  </style>
</head>
<body>
  <!-- 背景動畫（純星空，無連線） -->
  <canvas id="bg"></canvas>

  <!-- 主互動畫布 -->
  <canvas id="canvas"></canvas>
  <div id="hint">
    <div id="hint-orbit">相機（軌道）：<kbd>W/S</kbd> 縮放； <kbd>A/D</kbd> 左右環繞； <kbd>Q/E</kbd> 垂直移動 ｜ 左鍵：畫線。<kbd>T</kbd>：切換 Demo。</div>
    <div id="hint-fly" style="display:none;">相機（自由飛行）：<kbd>W</kbd>推進（沿鏡頭方向加速） <kbd>S</kbd>減速（不倒退） <kbd>A/D</kbd>左右平移 <kbd>Q/E</kbd>上/下；右鍵拖曳視角（飛行模式下禁止畫線）。</div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>

  <!-- 星空背景（多層星點 + 微微閃爍 + 緩慢視差） -->
  <script>
  (function(){
    const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const canvas = document.getElementById('bg');
    const ctx = canvas.getContext('2d');
    let W=0,H=0, stars=[];
    const LAYERS = [
      { countBase: 250, size:[0.4, 1.1],  speed: 0.02, alpha:[0.35,0.75] },
      { countBase: 180, size:[0.7, 1.6],  speed: 0.035, alpha:[0.4,0.85] },
      { countBase: 120, size:[1.0, 2.2],  speed: 0.06, alpha:[0.5,0.95] }
    ];

    function resize(){
      const w = Math.floor(window.innerWidth);
      const h = Math.floor(window.innerHeight);
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      canvas.width = w * DPR;
      canvas.height = h * DPR;
      W = canvas.width; H = canvas.height;
      spawn();
    }
    window.addEventListener('resize', resize);

    function rand(a,b){ return a + Math.random()*(b-a); }
    function spawn(){
      stars.length=0;
      for(const layer of LAYERS){
        const count = Math.round(layer.countBase * (W*H/(1600*900*DPR*DPR)));
        for(let i=0;i<count;i++){
          stars.push({
            x: Math.random()*W,
            y: Math.random()*H,
            r: rand(layer.size[0], layer.size[1]) * DPR,
            a: rand(layer.alpha[0], layer.alpha[1]),
            av: (Math.random()<0.5? -1:1) * rand(0.002, 0.01), // twinkle speed
            s: layer.speed * (0.6 + Math.random()*0.8),        // drift speed
            dir: Math.random()*Math.PI*2                        // drift direction
          });
        }
      }
    }

    function step(){
      for(const st of stars){
        // twinkle
        st.a += st.av;
        if (st.a < 0.2 || st.a > 1.0) st.av *= -1;
        // slow drift
        st.x += Math.cos(st.dir) * st.s * DPR;
        st.y += Math.sin(st.dir) * st.s * DPR;
        if (st.x < -5) st.x = W+5; if (st.x > W+5) st.x = -5;
        if (st.y < -5) st.y = H+5; if (st.y > H+5) st.y = -5;
      }
    }

    function draw(){
      ctx.setTransform(1,0,0,1,0,0);
      // 深藍黑到近黑的漸層，營造太空感
      const g = ctx.createRadialGradient(W*0.5, H*0.6, Math.min(W,H)*0.2, W*0.5, H*0.6, Math.max(W,H)*0.9);
      g.addColorStop(0,   '#0a0f1c');
      g.addColorStop(0.55,'#060a16');
      g.addColorStop(1,   '#010309');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);

      // 星點
      ctx.shadowBlur = 0;
      for(const st of stars){
        ctx.globalAlpha = Math.max(0.15, Math.min(1.0, st.a));
        ctx.fillStyle = '#cfe7ff';
        ctx.beginPath();
        ctx.arc(st.x, st.y, st.r, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    function loop(){ step(); draw(); requestAnimationFrame(loop); }
    resize(); loop();
  })();
  </script>

  <!-- ====== 你的主程式（含 FlyCam thrust：W 推進 / S 減速） ====== -->
  <script>
  (function () {
    const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    // --- Camera State (Orbit + Fly) ---
    const cam = {
      // Orbit
      theta:-1.6, phi:-0.2, radius:9000, velTheta:0, velPhi:0, damping:0.92,
      minPhi:-2, maxPhi:2, y:-4000,
      // Fly
      mode:'orbit', // 'orbit' | 'fly'
      pos:{x:0, y:-4000, z:0}, yaw:-1.6, pitch:-0.2,
    };

    const fly = {
      speed: 30,          // 左右/上下平移基礎速度（A/D/Q/E）
      sprint: 2.0,
      lookSensitivity: 0.0025,
      damping: 0.92,
      // === 推力模型（W=推進 / S=減速） ===
      thrust: 0,            // 當前推力
      thrustMax: 5000,      // 推力上限
      thrustGain: 80,       // 每幀按下W增加的推力量
      thrustBrake: 110,     // 每幀按下S減少的推力量
      thrustDrag: 0.985,    // 未操作時推力自然衰減（空中滑行）
      vel:{x:0,y:0,z:0}
    };

    function hslToRgb(h,s,l){ s/=100;l/=100;const k=n=>(n+h/30)%12;const a=s*Math.min(l,1-l);
      const f=n=>l-a*Math.max(-1,Math.min(k(n)-3,Math.min(9-k(n),1)));
      return {r:Math.round(255*f(0)),g:Math.round(255*f(8)),b:Math.round(255*f(4))}; }
    function randomNeonColor(){ const hues=[190,200,210,220,160,280,300,330,20,45];
      const h=hues[(Math.random()*hues.length)|0]+(Math.random()*10-5);
      return hslToRgb((h+360)%360, 96, 62); }
    function mod(n,m){ return ((n % m) + m) % m; }

    function Line(points, color){ this.points=points||[]; this.dist=0;
      color=color||randomNeonColor(); this.rgb=color;
      this.color='rgb('+~~(color.r)+','+~~(color.g)+','+~~(color.b)+')'; this.anchorRiseY=riseOffsetY; }
    Line.prototype.update=function(){ const p=this.points[this.points.length-1]; this.dist=p?p.z:0; };
    Line.prototype.render=function(ctxCore, _ctxGlow, translateY){
      const lw=settings.lineWidth*DPR; const pts2=scratch2D; pts2.length=0;

// --- Breathing Mode variant (single-line) ---
if (settings.breathingMode) {
  const t = performance.now() * (settings.breath_timeScale || 0.002);
  const phase = (this._phase ||= Math.random() * Math.PI * 2);
  const axis = (settings.breath_axis === 'y') ? 'y' : 'x';

  for (let i = 0; i < pts2.length; i++) {
    const p = pts2[i];
    const u = (pts2.length > 1) ? (i / (pts2.length - 1)) : 0;

    // 包絡：讓首尾較小、中段較大；可用 power 調整集中度
    const envelopeBase = Math.sin(u * Math.PI);
    const envelope = Math.pow(Math.max(0, envelopeBase), Math.max(0.1, settings.breath_envelopePow || 1));

    // 三段波形 + 基礎外擴
    const wave1 = Math.sin(t + phase) * (settings.breath_wave1Amp || 0);
    const wave2 = Math.sin(u * (settings.breath_wave2UFreq || 8) + t * (settings.breath_wave2TFreq || 2)) * (settings.breath_wave2Amp || 0);
    const wave3 = Math.cos(phase * (settings.breath_wave3PhaseMul || 4) - t)
                  * Math.pow(Math.cos(u * Math.PI - Math.PI / 2), 2)
                  * (settings.breath_wave3Amp || 0);
    const base = (settings.breath_baseline || 0);

    const delta = envelope * (wave1 + wave2 + wave3 + base);

    // 依軸向把位移加到 x 或 y
    p[axis] = p[axis] + delta;
  }
  // fall-through 繼續用變形後的 pts2 繪製
}
      for(let i=0;i<this.points.length;i++){ const p2=projectTo2DWithYOffset(this.points[i], translateY); if(p2) pts2.push(p2); }
      if(pts2.length<2) return;
      
      // --- Breathing Mode variant (single-line) ---
      if (settings.breathingMode) {
        const t = (performance.now() * 0.002);
        const phase = (this._phase ||= Math.random() * Math.PI * 2);
        for(let i=0;i<pts2.length;i++){
          const p = pts2[i];
          const u = (pts2.length>1)? (i/(pts2.length-1)) : 0;
          const envelope = Math.sin(u * Math.PI);
          const wave1 = Math.sin(t + phase) * 60;
          const wave2 = Math.sin(u*8 + t*2) * 40;
          const wave3 = Math.cos(phase*4 - t) * Math.pow(Math.cos(u*Math.PI - Math.PI/2), 2) * 100;
          const dx = envelope * (wave1 + wave2 + wave3 + 60);
          p.x = p.x + dx; // deform original line (no mirror)
        }
        // fall-through to original drawing using deformed pts2
      }
    

      if (settings.enableGlow) {
        ctxCore.save();
        ctxCore.setTransform(1,0,0,1,0,0);
        ctxCore.lineCap='round'; ctxCore.lineJoin='round';
        ctxCore.globalCompositeOperation = 'lighter';
        ctxCore.shadowBlur = (settings.glowStrength||8) * DPR;
        ctxCore.shadowColor = this.color;
        ctxCore.lineWidth = lw * 1.8;
        ctxCore.strokeStyle = 'rgba('+(this.rgb.r|0)+','+(this.rgb.g|0)+','+(this.rgb.b|0)+','+(settings.glowAlpha||0.45)+')';
        strokePath2D(ctxCore, pts2); ctxCore.stroke();
        ctxCore.restore();
      }

      ctxCore.save(); ctxCore.setTransform(1,0,0,1,0,0); ctxCore.lineCap='round'; ctxCore.lineJoin='round';
      ctxCore.lineWidth=lw; ctxCore.strokeStyle=this.color; ctxCore.shadowBlur=0; ctxCore.globalAlpha=1;
      strokePath2D(ctxCore, pts2); ctxCore.stroke(); ctxCore.restore();
    };
    function strokePath2D(ctx,pts){ ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y); for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y); }
    function PointWorld(x,y,z){ this.x=x||0; this.y=y||0; this.z=z||0; }
    function rotateY(v,a){ const c=Math.cos(a), s=Math.sin(a); return {x:v.x*c-v.z*s,y:v.y,z:v.z*c+v.x*s}; }
    function rotateX(v,a){ const c=Math.cos(a), s=Math.sin(a); return {x:v.x,y:v.y*c-v.z*s,z:v.z*c+v.y*s}; }

    // --- Projection (supports both orbit & fly) ---
    function projectTo2DWithYOffset(p,yoff){
      let v;
      if (cam.mode === 'fly') {
        v = { x: p.x - cam.pos.x, y: p.y + (yoff||0) - cam.pos.y, z: p.z - cam.pos.z };
        v = rotateY(v, -cam.yaw);
        v = rotateX(v, -cam.pitch);
        v.z += cam.radius; // reuse same near-plane push
      } else {
        v = { x:p.x, y:p.y+(yoff||0)-cam.y, z:p.z };
        v = rotateY(v, -cam.theta);
        v = rotateX(v, -cam.phi);
        v.z += cam.radius;
      }
      const scale=focal/(focal+v.z); if(scale<=0) return null;
      return {x:vpx+v.x*scale, y:vpy+v.y*scale};
    }

    function screenToWorldOnPlane(sx,sy,drawPlaneZ){
      const scaleInv=(focal+drawPlaneZ)/focal;
      const x_cam=(sx-vpx)*scaleInv; const y_cam=(sy-vpy)*scaleInv; const z_cam=drawPlaneZ;
      let v = {x:x_cam, y:y_cam, z:z_cam};
      if (cam.mode === 'fly') {
        v = rotateX(v, +cam.pitch);
        v = rotateY(v, +cam.yaw);
        return new PointWorld(v.x + cam.pos.x, v.y + cam.pos.y, v.z + cam.pos.z);
      } else {
        v = rotateX(v, +cam.phi);
        v = rotateY(v, +cam.theta);
        return new PointWorld(v.x, v.y+cam.y, v.z);
      }
    }

    const canvas=document.getElementById('canvas'); const ctx=canvas.getContext('2d',{alpha:true});
    ctx.imageSmoothingEnabled = true;
    let lines=[], focal=0, vpx=0, vpy=0,
        settings={ strokeColor:randomNeonColor(), lineWidth:0.9, demoMode:false, breathingMode:false, trailAlpha:0.16, orbitStep: 0.002,
                   maxLines:1200, maxPointsPerLine:60000, minSegmentLen:0.2,
                   riseSpeed:2, followRatio:0.35, drawPlaneZ:1200,
                   demoPointsPerFrame: 9, demoStepAmplitude: 900, demoNewLineChance: 0.96, demoPad: 24, demoFullScreen: false,
                   showFloor:true, showRightWall:true, gridStep:240, gridCell:600, gridHalf:10000, gridYRange:90000,
                   gridThin:'rgba(70,160,220,0.20)', gridThick:'rgba(130,210,255,0.45)', gridLabel:'rgba(190,230,255,0.9)', gridFontPx:16,
                   enableGlow:false, glowStrength:9, glowAlpha:0.55,

breath_timeScale: 0.002,   // 時間倍率（整體呼吸速度）
breath_axis: 'x',          // 變形軸向：'x' 或 'y'
breath_wave1Amp: 60,       // 波1 振幅（慢呼吸）
breath_wave2Amp: 40,       // 波2 振幅（細節顫動）
breath_wave2UFreq: 8,      // 波2 沿線 u 的頻率
breath_wave2TFreq: 2,      // 波2 隨時間的頻率
breath_wave3Amp: 100,      // 波3 振幅（中央鼓脹）
breath_wave3PhaseMul: 4,   // 波3 隨 phase 的倍數
breath_baseline: 60,       // 基礎外擴偏移（讓線條不會只左右擺而已）
breath_envelopePow: 1,     // 包絡線強度（>1 更集中於中段）
                   clearScreen(){ lines.length = 0; ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width,canvas.height); } },
        painting=false, points=[], line=null;
    const scratch2D=[]; let riseOffsetY=0;

    function resize(){ const w=Math.floor(window.innerWidth), h=Math.floor(window.innerHeight);
      canvas.style.width=w+'px'; canvas.style.height=h+'px'; canvas.width=w*DPR; canvas.height=h*DPR;
      focal=Math.max(canvas.width, canvas.height)/2; vpx=canvas.width/2; vpy=canvas.height/2;
      ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width,canvas.height);
    }
    window.addEventListener('resize', resize); resize();

    // --- Input ---
    const keys={w:false,s:false,a:false,d:false,q:false,e:false,shift:false,t:false};
    const KEYMAP={87:'w',83:'s',65:'a',68:'d',81:'q',69:'e',84:'t',16:'shift'};
    window.addEventListener('keydown', e=>{ const k=KEYMAP[e.keyCode]; if(k&&keys[k]!==undefined){ keys[k]=true; e.preventDefault(); }
      if(e.keyCode===84){ settings.demoMode = !settings.demoMode; if(settings.demoMode) line=null; }
    });
    window.addEventListener('keyup', e=>{ const k=KEYMAP[e.keyCode]; if(k&&keys[k]!==undefined){ keys[k]=false; e.preventDefault(); }});

    const mouse={down:false, look:false, lastX:0, lastY:0};

    // 飛行模式規則：禁止畫線。右鍵僅用於視角拖曳
    canvas.addEventListener('mousedown', e=>{
      if (cam.mode==='fly') {
        if(e.button===2){ mouse.look=true; mouse.lastX=e.clientX; mouse.lastY=e.clientY; }
        return;
      }
      if(e.button!==0) return; settings.demoMode=false; mouse.down=true; painting=true;
      const rect=canvas.getBoundingClientRect(); const startX=(e.clientX-rect.left)*DPR; const startY=(e.clientY-rect.top)*DPR;
      points=[]; line=new Line(points, randomNeonColor()); lines.push(line); if(lines.length>settings.maxLines) lines.splice(0, lines.length-settings.maxLines);
      addPointWorldFromScreen(startX, startY);
    });
    window.addEventListener('mouseup', e=>{ if(e.button===2){ mouse.look=false; return; } mouse.down=false; painting=false; line=null; });
    canvas.addEventListener('contextmenu', e=>{ e.preventDefault(); });

    canvas.addEventListener('mousemove', e=>{
      if(mouse.look && cam.mode==='fly'){
        const dx = e.clientX - mouse.lastX; const dy = e.clientY - mouse.lastY;
        mouse.lastX = e.clientX; mouse.lastY = e.clientY;
        // 右鍵拖曳視角（FPS/Unreal）
        cam.yaw   += dx * fly.lookSensitivity;
        cam.pitch -= dy * fly.lookSensitivity;
        cam.pitch = Math.max(-2, Math.min(2, cam.pitch));
        return;
      }
      if(!mouse.down||!line) return; const rect=canvas.getBoundingClientRect();
      const x=(e.clientX-rect.left)*DPR; const y=(e.clientY-rect.top)*DPR; addPointWorldFromScreen(x,y);
    });

    function addPointWorldFromScreen(sx,sy){
      const L=line.points.length; const world=screenToWorldOnPlane(sx,sy,settings.drawPlaneZ*DPR);
      if(L>0){ const last=line.points[L-1]; const dx=world.x-last.x, dy=world.y-last.y, dz=world.z-last.z;
        if(dx*dx+dy*dy+dz*dz < (settings.minSegmentLen*settings.minSegmentLen)) return; } line.points.push(world); }

    // ---------- Demo helpers ----------
    function startDemoLine() {
      points = [];
      line = new Line(points, randomNeonColor());
      lines.push(line);
      if (lines.length > settings.maxLines) lines.splice(0, lines.length - settings.maxLines);

      if (settings.demoFullScreen) {
        const pad = Math.max(0, (settings.demoPad|0)) * DPR;
        const sx = pad + Math.random() * (canvas.width - pad * 2);
        const sy = pad + Math.random() * (canvas.height - pad * 2);
        const world0 = screenToWorldOnPlane(sx, sy, settings.drawPlaneZ * DPR);
        line.points.push(world0);
      } else {
        line.points.push(new PointWorld(
          (Math.random()-0.5) * settings.demoStepAmplitude * DPR,
          0,
          (Math.random()-0.5) * settings.demoStepAmplitude * DPR
        ));
      }
    }

    // --- Grid ---
    function drawFloorAndRightWall(){ const step=settings.gridStep*DPR, cell=settings.gridCell*DPR, half=settings.gridHalf*DPR, yRange=settings.gridYRange*DPR;
      const baseY=-(riseOffsetY % step);
      if(settings.showFloor){ for(let x=-half;x<=half;x+=cell){ const pA=projectTo2DWithYOffset({x,y:-300,z:-half},0), pB=projectTo2DWithYOffset({x,y:-300,z:half},0); if(pA&&pB) strokeGridLine(pA,pB,false); }
        for(let z=-half;z<=half;z+=cell){ const pA=projectTo2DWithYOffset({x:-half,y:-10,z},0), pB=projectTo2DWithYOffset({x:half,y:-10,z},0); if(pA&&pB) strokeGridLine(pA,pB,false);} }
      if(settings.showRightWall){ const wallX=half; for(let z=-half;z<=half;z+=cell){ const pA=projectTo2DWithYOffset({x:wallX,y:Math.min(-10,baseY-yRange),z},0);
          const pB=projectTo2DWithYOffset({x:wallX,y:Math.min(-10,baseY+yRange),z},0); if(pA&&pB) strokeGridLine(pA,pB,false); }
        const levels=Math.ceil((2*yRange)/step)+2;
        for(let i=-levels;i<=levels;i++){ const y=baseY+i*step; if(y>-10) continue; const idx=Math.round((riseOffsetY+y)/step);
          const labelVal=mod(idx,31); const isMajor=(labelVal%5===0);
          const pA=projectTo2DWithYOffset({x:wallX,y,z:-half},0), pB=projectTo2DWithYOffset({x:wallX,y,z:half},0); if(pA&&pB) strokeGridLine(pA,pB,isMajor);
          const labelPos=projectTo2DWithYOffset({x:wallX+200*DPR,y,z:half*0.6},0); if(labelPos&&y<=-10) drawLabel(labelPos.x,labelPos.y,labelVal); } } }
    function strokeGridLine(p1,p2,major){ ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y);
      ctx.lineWidth=(major?1.6:1.0)*DPR; ctx.strokeStyle=major?settings.gridThick:settings.gridThin; ctx.stroke(); ctx.restore(); }
    function drawLabel(x,y,val){ ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.font=(settings.gridFontPx*DPR)+'px ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial';
      ctx.fillStyle=settings.gridLabel; ctx.textAlign='left'; ctx.textBaseline='middle'; ctx.fillText(String(val),x,y); ctx.restore(); }

    function loop(){
      // Camera update
      if (cam.mode === 'fly') {
        const base = fly.speed * DPR * (keys.shift ? fly.sprint : 1);

        // === Unreal / FPS style forward = 視角方向 ===
        const cy = Math.cos(cam.yaw), sy = Math.sin(cam.yaw);
        const cp = Math.cos(cam.pitch), sp = Math.sin(cam.pitch);
        const fwd   = { x: Math.sin(cam.yaw) * Math.cos(cam.pitch),
                        y: -Math.sin(cam.pitch),
                        z: Math.cos(cam.yaw) * Math.cos(cam.pitch) };
        const right = { x: cy, y: 0, z: -sy };
        const up    = { x: 0,  y: 1, z: 0 };

        // --- 推力邏輯：W=推進 / S=減速（不倒退） ---
        if (keys.w) fly.thrust += fly.thrustGain * DPR;
        if (keys.s) fly.thrust -= fly.thrustBrake * DPR;

        // 未操作時自然衰減（像鬆油門空滑）
        if (!keys.w && !keys.s) {
          fly.thrust *= fly.thrustDrag;
        }

        // 限制推力範圍（不小於0、不超過上限）
        fly.thrust = Math.max(-10000, Math.min(fly.thrust, fly.thrustMax * DPR));

        // 依推力沿鏡頭方向推進（推力→速度輸入）
        let vx = fwd.x * fly.thrust * -0.02;
        let vy = fwd.y * fly.thrust * 0.02;
        let vz = fwd.z * fly.thrust * 0.02;

        // 平移（A/D/Q/E）維持原本感覺
        if (keys.a) { vx -= right.x*base; vy -= right.y*base; vz += right.z*base; }
        if (keys.d) { vx += right.x*base; vy += right.y*base; vz -= right.z*base; }
        if (keys.q) { vx += up.x*base;   vy += up.y*base;   vz += up.z*base; }
        if (keys.e) { vx -= up.x*base;   vy -= up.y*base;   vz -= up.z*base; }

        // 平滑阻尼（慣性）
        fly.vel.x = fly.vel.x*fly.damping + vx*(1-fly.damping);
        fly.vel.y = fly.vel.y*fly.damping + vy*(1-fly.damping);
        fly.vel.z = fly.vel.z*fly.damping + vz*(1-fly.damping);

        cam.pos.x += fly.vel.x;
        cam.pos.y += fly.vel.y;
        cam.pos.z += fly.vel.z;

        if((painting || settings.demoMode) && !window.__IMPORTING){
          riseOffsetY += settings.riseSpeed*DPR;
        }
      } else {
        const zoomStep=40*DPR, yStep=60*DPR, orbit=(settings.orbitStep||0.02);
        if (keys.w) cam.radius -= zoomStep;
        if (keys.s) cam.radius += zoomStep;
        if (keys.a) cam.velTheta += orbit;
        if (keys.d) cam.velTheta -= orbit;
        if (keys.q) cam.y += yStep;
        if (keys.e) cam.y -= yStep;

        cam.theta += cam.velTheta; cam.velTheta*=cam.damping; cam.velPhi*=cam.damping;
        cam.phi = Math.max(cam.minPhi, Math.min(cam.maxPhi, cam.phi));

        if((painting || settings.demoMode) && !window.__IMPORTING){
          riseOffsetY += settings.riseSpeed*DPR; cam.y -= settings.riseSpeed*settings.followRatio*DPR;
        }
      }

      // Render
      ctx.setTransform(1,0,0,1,0,0); if(settings.breathingMode){   ctx.globalCompositeOperation='destination-out';   ctx.globalAlpha=(settings.trailAlpha||0.12);   ctx.fillStyle='#000';   ctx.fillRect(0,0,canvas.width,canvas.height);   ctx.globalCompositeOperation='source-over';   ctx.globalAlpha=1; } else {   ctx.globalCompositeOperation='source-over';   ctx.globalAlpha=1;   ctx.clearRect(0,0,canvas.width,canvas.height); } // 主畫布清畫（背景自己畫在 #bg）
      drawFloorAndRightWall();

      // --- Demo ---
      if (settings.demoMode && !window.__IMPORTING) {
        if (!line) { startDemoLine(); }
        else {
          const last = line.points[line.points.length-1];
          const amp = settings.demoStepAmplitude * DPR;
          for (let k = 0; k < Math.max(1, (settings.demoPointsPerFrame|0)); k++) {
            const nx = last.x + (Math.random() - 0.5) * amp;
            const ny = last.y + (Math.random() - 0.5) * amp * 0.6;
            const nz = last.z + (Math.random() - 0.5) * amp;
            const world = new PointWorld(nx, ny, nz);
            const dx = world.x - last.x, dy = world.y - last.y, dz = world.z - last.z;
            if ((dx*dx + dy*dy + dz*dz) > (settings.minSegmentLen * settings.minSegmentLen)) {
              line.points.push(world);
            }
          }
          if (Math.random() > settings.demoNewLineChance) { line = null; settings.strokeColor = randomNeonColor(); }
        }
      }

      const active=line; lines.sort((a,b)=>b.dist-a.dist); for(let i=0;i<lines.length;i++) lines[i].update();
      for(let i=0;i<lines.length;i++){ const ln=lines[i]; const yoff=(ln===active)?0:(riseOffsetY - ln.anchorRiseY); ln.render(ctx, null, yoff); }
      requestAnimationFrame(loop);
    }

    // GUI (dat.GUI)
    const gui=new dat.GUI();
    const camUI=gui.addFolder('Camera'); camUI.add(settings, 'orbitStep', 0.0001, 0.02, 0.001).name('左右旋轉速度').listen();
    camUI.add(cam,'radius',400,20000,10).name('鏡頭前後').listen();
    camUI.add(cam,'theta',-Math.PI,Math.PI,0.01).name('鏡頭左右').listen(); camUI.add(cam,'phi',-2,2,0.01).name('鏡頭仰角').listen(); camUI.add(cam,'y',-20000,20000,50).listen(); camUI.close();
    const drawUI=gui.addFolder('Draw'); drawUI.add(settings,'drawPlaneZ',200,3000,50).name('前方平面距離').listen(); drawUI.close();
    const look=gui.addFolder('Look');

// === Breathing 調整 ===
try {
  const breathUI = gui.addFolder('Breathing 調整');
  breathUI.add(settings, 'breath_timeScale', 0.0005, 0.01, 0.0001).name('時間倍率').listen();
  breathUI.add(settings, 'breath_axis', ['x','y']).name('變形軸');
  breathUI.add(settings, 'breath_wave1Amp', 0, 200, 1).name('波1 振幅');
  breathUI.add(settings, 'breath_wave2Amp', 0, 200, 1).name('波2 振幅');
  breathUI.add(settings, 'breath_wave2UFreq', 0, 32, 0.5).name('波2 u頻率');
  breathUI.add(settings, 'breath_wave2TFreq', 0, 10, 0.1).name('波2 時間頻率');
  breathUI.add(settings, 'breath_wave3Amp', 0, 300, 1).name('波3 振幅');
  breathUI.add(settings, 'breath_wave3PhaseMul', 0, 10, 0.1).name('波3 相位倍數');
  breathUI.add(settings, 'breath_baseline', -200, 200, 1).name('基礎外擴');
  breathUI.add(settings, 'breath_envelopePow', 0.3, 4, 0.1).name('包絡強度');
  breathUI.close();
} catch (e) { console.warn('Breathing UI attach failed', e); }
 look.add(settings,'breathingMode').name('Breathing 模式').listen(); look.add(settings,'trailAlpha',0.02,0.3,0.01).name('殘影Alpha').listen(); 
    look.add(settings,'lineWidth',0.4,3,0.1).name('線寬(細)').listen();
    look.add(settings,'enableGlow').name('啟用微光').listen();
    look.add(settings,'glowStrength',0,50,1).name('微光強度').listen();
    look.add(settings,'glowAlpha',0.05,1,0.01).name('微光透明度').listen();
    const misc=gui.addFolder('其他'); misc.add({clear:settings.clearScreen},'clear').name('清空'); misc.add(settings,'riseSpeed',0,10,0.1).name('上升速度');
    misc.add(settings,'followRatio',0,1.2,0.05).name('鏡頭跟隨比例'); misc.close();
    const demoUI = gui.addFolder('Demo');
    demoUI.add(settings, 'demoMode').name('Demo 模式');
    demoUI.add(settings, 'demoFullScreen').name('全版起筆');
    demoUI.add(settings, 'demoPointsPerFrame', 1, 40, 1).name('每幀點數').listen();
    demoUI.add(settings, 'demoStepAmplitude', 50, 2000, 10).name('步幅(世界)').listen();
    demoUI.add(settings, 'demoNewLineChance', 0.5, 0.995, 0.005).name('續畫機率').listen();
    demoUI.add(settings, 'demoPad', 0, 200, 1).name('邊界內縮').listen();

    // --- Top UI (Import / Export / FlyCam) ---
    const wrap=document.createElement('div'); wrap.className='topbar'; document.body.appendChild(wrap);
    function mkBtn(text){ const b=document.createElement('button'); b.textContent=text; b.className='btn'; wrap.appendChild(b); return b; }
    function mkChk(text, checked){ const l=document.createElement('label'); l.className='lbl'; l.innerHTML='<input type="checkbox" '+(checked?'checked':'')+'> '+text; wrap.appendChild(l); return l.querySelector('input'); }
    function mkNum(text, val, step){ const l=document.createElement('label'); l.className='lbl'; l.innerHTML=text+' <input class="num" type="number" step="'+(step||1)+'" value="'+val+'">'; wrap.appendChild(l); return l.querySelector('input'); }

    const btnImp = mkBtn('匯入');
    const btnExp = mkBtn('匯出');
    const chkClear = mkChk('匯入前清空', true);
    const chkProgress = mkChk('逐點重繪（注入）', true);
    const liftInput = mkNum('每檔Y位移(世界單位)', -500, 1);

    const sep = document.createElement('span'); sep.style.margin='0 6px'; sep.textContent='|'; wrap.appendChild(sep);

    const chkFly = mkChk('自由飛行 FlyCam（禁畫）', false);
    const speedInput = mkNum('飛行速度', fly.speed, 50);

    /* === 這裡新增兩個獨立開關：顯示 floor / 顯示 rightWall === */
    const sep2 = document.createElement('span'); sep2.style.margin='0 6px'; sep2.textContent='|'; wrap.appendChild(sep2);

    const chkFloor = mkChk('顯示 floor', true);
    chkFloor.checked = !!settings.showFloor;
    chkFloor.addEventListener('change', ()=>{ settings.showFloor = chkFloor.checked; });

    const chkRightWall = mkChk('顯示 rightWall', true);
    chkRightWall.checked = !!settings.showRightWall;
    chkRightWall.addEventListener('change', ()=>{ settings.showRightWall = chkRightWall.checked; });
    /* === 新增開關結束 === */

    const fileInput=document.createElement('input'); fileInput.type='file'; fileInput.accept='.json,application/json'; fileInput.multiple=true; fileInput.style.display='none'; document.body.appendChild(fileInput);
    btnImp.onclick=()=> fileInput.click();

    function updateHints(){
      document.getElementById('hint-orbit').style.display = (cam.mode==='orbit')?'':'none';
      document.getElementById('hint-fly').style.display = (cam.mode==='fly')?'':'none';
    }

    chkFly.addEventListener('change', ()=>{
      if (chkFly.checked){
        cam.mode = 'fly';
        const yaw = cam.theta; const pitch = cam.phi;
        const cy = Math.cos(yaw), sy = Math.sin(yaw), cp=Math.cos(pitch), sp=Math.sin(pitch);
        const eye = { x: -(Math.sin(yaw)*cp)*cam.radius, y: sp*cam.radius + cam.y, z: -(Math.cos(yaw)*cp)*cam.radius };
        cam.pos.x = 0;
		cam.pos.y = 0;
		cam.pos.z = 0;
        cam.yaw = yaw; cam.pitch = pitch; settings.followRatio = 0;
      } else {
        cam.mode = 'orbit';
      }
      updateHints();
    });

    speedInput.addEventListener('change', ()=>{ const v = parseFloat(speedInput.value); if (isFinite(v) && v>0) fly.speed = v; });

    // 匯出（世界座標）
    btnExp.onclick = () => {
      try{
        const env = window._sketchEnv || {};
        const linesRef = window.lines || env.lines;
        const payload = { meta:{ type:'strokesWorld', app:'3D_Sketcher_Grid', dpr: window.devicePixelRatio, exportedAt:new Date().toISOString(), version:'demo_glow_fix_fly_thrust_spacebg' }, strokesWorld: [] };
        if (Array.isArray(linesRef)) {
          for (const L of linesRef) {
            const raw = Array.isArray(L?.points) ? L.points
                      : Array.isArray(L?.pts) ? L.pts
                      : Array.isArray(L?.vertices) ? L.vertices
                      : (typeof L?.getPoints === 'function' ? (L.getPoints() || []) : []);
            const pts = Array.isArray(raw) ? raw.map(p =>
              Array.isArray(p) ? {x:+p[0]||0, y:+p[1]||0, z:+p[2]||0}
                               : {x:+p.x||0,  y:+p.y||0,  z:+p.z||0}
            ) : [];
            if (pts.length >= 2) {
              const entry = { points: pts };
              if (typeof L.color === 'string') entry.color = L.color;
              payload.strokesWorld.push(entry);
            }
          }
        }
        if (!payload.strokesWorld.length) { alert('目前沒有線條可匯出'); return; }
        const blob = new Blob([JSON.stringify(payload, null, 2)], {type:'application/json'});
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'lines_export_' + Date.now() + '.json';
        document.body.appendChild(a); a.click(); a.remove(); setTimeout(() => URL.revokeObjectURL(a.href), 1500);
      }catch(err){ console.error('[export]', err); alert('匯出失敗：' + err.message); }
    };

    // 匯入（與先前版本相容的逐點注入）
    const perPointDelay = 12;
    fileInput.onchange = async (e) => {
      const files = Array.from(e.target.files || []);
      if(!files.length) return;
      try{
        const env = window._sketchEnv || {};
        if(chkClear.checked){
          if(env.settings && typeof env.settings.clearScreen==='function') env.settings.clearScreen();
          if(Array.isArray(env.lines)) env.lines.length = 0;
        }

        const prevFollow = env.settings ? env.settings.followRatio : 0;
        if(env.settings) env.settings.followRatio = 0;
        window.__IMPORTING=true;

        const BASE_LIFT = (+liftInput.value || 0) * (env.DPR||1);
        const DRAW_Z = (env.settings?.drawPlaneZ || 1200) * (env.DPR||1);

        function mapStrokePoints(s, scaleDPR, extraY){
          const raw = Array.isArray(s.points)? s.points : [];
          const lift = extraY || 0;
          return raw.map(p => ({ x:(+p.x||0)*scaleDPR, y:(+p.y||0)*scaleDPR + lift, z:(p.z!=null? +p.z*scaleDPR : DRAW_Z) }));
        }

        async function injectProgressively(strokes, scaleDPR, fileLift){
          async function appendPointsToLine(lineObj, pts){
            for(let i=1;i<pts.length;i++){
              lineObj.points.push(pts[i]);
              await new Promise(r=>requestAnimationFrame(r));
              if(perPointDelay>0) await new Promise(r=>setTimeout(r, perPointDelay));
            }
          }
          for(const s of strokes){
            const pts = mapStrokePoints(s, scaleDPR, fileLift);
            if(pts.length>=2){
              const newL = env._appendLine ? env._appendLine([pts[0]]) : window._appendLine([pts[0]]);
              await appendPointsToLine(newL, pts);
            }
          }
        }

        let totalStrokes = 0;
        for(let i=0;i<files.length;i++){
          const f = files[i];
          const fileLift = (BASE_LIFT||0) * i;
          const text = await f.text();
          const data = JSON.parse(text);
          const strokes = Array.isArray(data?.strokesWorld)? data.strokesWorld : [];
          const exportDPR = (data.meta && +data.meta.dpr) || 1;
          const scaleDPR = exportDPR>0 ? (env.DPR / exportDPR) : 1;
          await injectProgressively(strokes, scaleDPR, fileLift);
          totalStrokes += strokes.length;
        }

        if(env.settings) env.settings.followRatio = prevFollow;
        window.__IMPORTING=false;
        for(const fn of ['tick','render','draw','animate','frame']){ if(typeof window[fn]==='function'){ try{ window[fn](); }catch(e){} } }
        alert('匯入完成：'+files.length+' 檔（總筆數約 '+totalStrokes+'）');
      }catch(err){
        console.error('[import]',err);
        alert('匯入失敗：'+err.message);
      } finally {
        e.target.value='';
        window.__IMPORTING=false;
      }
    };

    // Expose
    window._sketchEnv={lines, settings, DPR, screenToWorldOnPlane, Line}; window.__IMPORTING=false;
    window._appendLine = function(points, color){
      const L = new Line(points.slice(), color || randomNeonColor());
      lines.push(L);
      return L;
    };

    requestAnimationFrame(loop);
  })();
  </script>

  <!-- ==== Import rise-per-point patch v4 ==== -->
  <script>
  (function(){
    function getRisePerPoint(){
      const env = window._sketchEnv || {};
      const dpr = env.DPR || window.devicePixelRatio || 1;
      const speed = (env.settings && typeof env.settings.riseSpeed === 'number') ? env.settings.riseSpeed : 0;
      return speed * dpr;
    }
    function ensureImportState(){ if (window.__IMPORT_RISE_LAST_Y === undefined) window.__IMPORT_RISE_LAST_Y = null; if (window.__IMPORT_RISE_ACTIVE === undefined) window.__IMPORT_RISE_ACTIVE = false; }
    function wrapAppendLine(){
      const origAppend = window._appendLine; if (!origAppend || window._appendLine.__wrappedRiseV4) return;
      window._appendLine = function(points, color){
        ensureImportState(); const importing = !!window.__IMPORTING; const rise = getRisePerPoint();
        const pts = Array.isArray(points) ? points.map(p => ({x:p.x, y:p.y, z:p.z})) : [];
        const line = origAppend.call(this, pts, color);
        if (importing && line && Array.isArray(line.points) && !line.points.__pushWrappedRiseV4) {
          window.__IMPORT_RISE_ACTIVE = true;
          if (line.points.length >= 1) {
            const first = line.points[0];
            if (window.__IMPORT_RISE_LAST_Y == null) { window.__IMPORT_RISE_LAST_Y = first.y; }
            else { first.y = window.__IMPORT_RISE_LAST_Y - rise; window.__IMPORT_RISE_LAST_Y = first.y; }
          }
          for (let i = 1; i < line.points.length; i++) { line.points[i].y = line.points[i-1].y - rise; window.__IMPORT_RISE_LAST_Y = line.points[i].y; }
          const origPush = line.points.push.bind(line.points);
          line.points.push = function(p){ const baseY = (window.__IMPORT_RISE_LAST_Y != null) ? window.__IMPORT_RISE_LAST_Y : (line.points.length ? line.points[line.points.length - 1].y : (p && p.y) || 0); const newPt = { x: p.x, y: baseY - rise, z: p.z }; window.__IMPORT_RISE_LAST_Y = newPt.y; return origPush(newPt); };
          line.points.__pushWrappedRiseV4 = true; console.log('[import/rise v4] cumulative across lines enabled.');
        }
        return line;
      };
      window._appendLine.__wrappedRiseV4 = true; console.log('[import/rise v4] _appendLine wrapped (cumulative across lines).');
    }
    function monitorImportFlag(){ ensureImportState(); if (!window.__IMPORT_RISE_ACTIVE) return; if (!window.__IMPORTING) { window.__IMPORT_RISE_LAST_Y = null; window.__IMPORT_RISE_ACTIVE = false; console.log('[import/rise v4] import finished, reset last Y.'); } setTimeout(monitorImportFlag, 300); }
    function init(){ try{ wrapAppendLine(); }catch(e){ console.warn(e); } setTimeout(monitorImportFlag, 300); }
    init(); window.addEventListener('load', init); setTimeout(init, 300); setTimeout(init, 1200); setTimeout(init, 2500);
  })();
  </script>


  <!-- ===== Stars-only Background + Afterimage (残影) ===== -->
  <style>
    #__bg_stars_container{position:fixed; inset:0; z-index:0; pointer-events:none;}
    :root{ --bg-1:#03010c; --bg-2:#0d0a1f; }
    body#__stars_bg_on{
      background:
        radial-gradient(1200px 1200px at 70% 20%, #171233 0%, var(--bg-2) 35%, var(--bg-1) 75%) fixed,
        linear-gradient(180deg, #000008 0%, #000010 100%) fixed;
    }
  </style>
  <div id="__bg_stars_container"></div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.161.0/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
  import * as THREE from 'three';
  import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
  import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
  import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
  import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';
  import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';

  // Enable star BG body theme
  try{ document.body.id = '.__stars_bg_on'.slice(1);}catch(e){}

  const DPR = Math.min(window.devicePixelRatio || 1, matchMedia('(pointer:coarse)').matches ? 1.2 : 1.75);
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 220);
  camera.position.set(0, 0, 20);

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setPixelRatio(DPR);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.setClearAlpha(0);
  Object.assign(renderer.domElement.style, { position:'fixed', inset:'0', zIndex:'0', pointerEvents:'none' });
  document.getElementById('__bg_stars_container').appendChild(renderer.domElement);

  // ---------- Stars ----------
  function hexCol(h){ return new THREE.Color(h); }
  const palette = { starA: hexCol('#c9a7ff'), starB: hexCol('#9deaff') };

  function makeStars(count=3400){
    const pos = new Float32Array(count*3);
    const scale = new Float32Array(count);
    const phase = new Float32Array(count);
    for(let i=0;i<count;i++){
      const R = THREE.MathUtils.randFloat(14, 46);
      const theta = THREE.MathUtils.randFloat(0, Math.PI*2);
      const phi = Math.acos(THREE.MathUtils.randFloatSpread(1));
      pos[i*3+0] = R*Math.sin(phi)*Math.cos(theta);
      pos[i*3+1] = R*Math.cos(phi);
      pos[i*3+2] = R*Math.sin(phi)*Math.sin(theta);
      scale[i] = THREE.MathUtils.randFloat(1.0, 2.2);
      phase[i] = THREE.MathUtils.randFloat(0, Math.PI*2);
    }
    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
    geo.setAttribute('aScale', new THREE.BufferAttribute(scale,1));
    geo.setAttribute('aPhase', new THREE.BufferAttribute(phase,1));
    const v = `
      uniform float uTime;
      attribute float aScale, aPhase;
      varying float vAlpha;
      void main(){
        vec4 mv = modelViewMatrix * vec4(position,1.0);
        float dist = length(mv.xyz);
        float flicker = 0.6 + 0.4*sin(uTime*2.0 + aPhase);
        vAlpha = 0.65 * flicker;
        float size = aScale * (40.0 / dist);
        gl_PointSize = size;
        gl_Position = projectionMatrix * mv;
      }`;
    const f = `
      precision highp float;
      uniform vec3 uStarA; uniform vec3 uStarB;
      varying float vAlpha;
      void main(){
        vec2 uv = gl_PointCoord*2.0-1.0;
        float d = dot(uv,uv);
        float soft = smoothstep(1.0, 0.0, d);
        vec3 col = mix(uStarA, uStarB, soft);
        gl_FragColor = vec4(col, vAlpha*soft);
      }`;
    const mat = new THREE.ShaderMaterial({
      uniforms:{ uTime:{value:0}, uStarA:{value:palette.starA.clone()}, uStarB:{value:palette.starB.clone()} },
      vertexShader:v, fragmentShader:f, transparent:true, blending:THREE.AdditiveBlending, depthWrite:false
    });
    return new THREE.Points(geo, mat);
  }

  const stars = makeStars(3400);
  scene.add(stars);

  // ---------- Post FX with Afterimage (trail) ----------
  const composer = new EffectComposer(renderer);
  composer.addPass(new RenderPass(scene, camera));

  const fxaaPass = new ShaderPass(FXAAShader);
  fxaaPass.material.uniforms['resolution'].value.set(1/(window.innerWidth*DPR), 1/(window.innerHeight*DPR));
  composer.addPass(fxaaPass);

  // ★★ 殘影效果 ★★
  const trailPass = new AfterimagePass();
  trailPass.uniforms['damp'].value = 0.92;  // lower = longer trails (e.g., 0.86)
  composer.addPass(trailPass);

  const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.25, 0.4, 0.2);
  composer.addPass(bloomPass);

  composer.addPass(new OutputPass());

  let t = 0;
  function animate(){
    requestAnimationFrame(animate);
    t += 1/60;
    stars.material.uniforms.uTime.value = t;
    stars.rotation.y += 0.002;
    stars.rotation.x += 0.001;
    composer.render();
  }
  animate();

  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
    fxaaPass.material.uniforms['resolution'].value.set(1/(window.innerWidth*DPR), 1/(window.innerHeight*DPR));
  });
  </script>

</body>
</html>
